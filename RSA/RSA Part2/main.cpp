/*RSA encryption algorithm part 2
 * Author: Nicholas Smith
 * Part 2 takes the generated keys from part 1 and 
 * encrypts a message or verifies authenticity of 
 * an already encrypted message.
 */
#include <fstream>
#include <stdlib.h> 
#include <iostream>
#include "sha256.h"
#include "BigIntegerLibrary.hh"

using std::string;
using std::cout;
using std::endl;

string readFile(string);
string readFile(string*, string);
BigUnsigned stringToBase16BigUnsigned(string);
string createSignature(string);
 
int main(int argc, char *argv[])
{
	BigUnsigned n = BigUnsigned(1);
	BigUnsigned e = BigUnsigned(3);
	BigUnsigned d = BigUnsigned(1);
	string nstring = "";
	std::ifstream file;
	std::ofstream signFile;

	string fileToReadOrWrite = argv[2];
	string message = readFile(fileToReadOrWrite);

	/* if s, then we must create a signed document to encrypt the given file. */
	if (*argv[1] == 's') {
		string dstring = "";
		fileToReadOrWrite.append(".signed");
		file.open("d_n.txt");
		file >> dstring;
		file >> nstring;
		d = stringToBigUnsigned(dstring);
		n = stringToBigUnsigned(nstring);

		/* sha256 is a cryptic set of hash functions to create a digital signature
		 *  for security and checking authenticity. */
		string hash = sha256(message);
		/* Create our digital signature to be written to a file. */
		string messageSignature = createSignature(hash, d, n);

		signFile.open(fileToReadOrWrite.c_str());
		signFile << messageSignature << endl << message;
		signFile.close();
		file.close();
	} if (*argv[1] == 'v') {
		string estring = "";
		string encryptedMessage, messageSignature;
	    /*We need the public key to decrypt our message 
             * so open our file and convert the key values to BigUnsigned */
		file.open("e_n.txt");
		file >> estring;
		file >> nstring;
		e = stringToBigUnsigned(estring);
		n = stringToBigUnsigned(nstring);
		file.close();

		/* Read encrypted message, passes messageSign by reference */
		encryptedMessage = readFile(&messageSignature, fileToReadOrWrite);
		
		/* convert message and signature to base 16 integer for comparison.
		 * Comparison will be done to verify if our old message has not been 
		 * tampered with */
		encryptedMessage = sha256(encryptedMessage);
		BigUnsigned oldMessage = stringToBase16BigUnsigned(encryptedMessage);
		BigUnsigned messageHash = stringToBase16BigUnsigned(messageSignature);

		/* decrypt using the formula ((M^d % n)^e) % n, where messageHash = M^d % n*/
		BigUnsigned decryption = modexp(messageHash, e, n);

		if (decryption.compareTo(oldMessage) != 0) 
			cout << "Your message has been modified!" << endl;
		else 
			cout << "Your message is authentic." << endl;
	}
    return 0;
}
/* Converts string to a base 16 BigUnsigned object */
BigUnsigned stringToBase16BigUnsigned(string s) {
	BigUnsignedInABase base16Message = BigUnsignedInABase(s, 16);
	return BigUnsignedInABase(base16Message);
}

/* Opens a file based on the file name given. */
string readFile(std::string fileName) {
	std::ifstream file(fileName.c_str());
	std::string temp = "", m = "";
	if (file.is_open()) {
		while (!file.eof()) {
			file >> temp;
			m += temp + " ";
		}
		m.resize(m.size() - 1);
		file.close();
		return m;
	}
	else {
		cout << "File did not open" << endl;
		exit(0);
	}
	return 0;
}
/* Overload function for readFile when we are verifying an already
*  encrypted message. This is called to read the signature located at
*  the first line of our given file. The rest is read normally.*/
string readFile(string *messageSign, string fileName) {
	std::ifstream file(fileName.c_str());
	std::string temp = "", m = "";
	if (file.is_open()) {
		file >> *messageSign;
		while (!file.eof()) {
			file >> temp;
			m += temp + " ";
		}
		m.resize(m.size() - 1);
		file.close();
		return m;
	}
	else {
		cout << "File did not open" << endl;
		exit(0);
	}
	return 0;
}
/* Create signature using the given hash generated by sha256. 
 *  RSA encryption algorithm uses the formula M^d % n to encrypt, 
 *  where M is our message and (d,n) is our private key. */
string createSignature(string hash, BigUnsigned d, BigUnsigned n) {
	BigUnsignedInABase base16Message = BigUnsignedInABase(hash, 16);
	BigUnsigned unSignedMessage = BigUnsigned(base16Message);

	/* creates signature */
	BigUnsigned messageSignature = modexp(unSignedMessage, d, n);

	/*convert back to base 16 integer so we can convert to string*/
	base16Message = BigUnsignedInABase(messageSignature, 16);

	return BigUnsignedInABase(base16Message);
}
